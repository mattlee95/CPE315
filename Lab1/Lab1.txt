   unsigned char bytestring_swap_int[] = {0x80, 0x54, 0x33, 0x41, 0x78, 0x01, 0x99, 0xFF, 0xEE, 0xFE, 0x20, 0x55, 0x00, 0x00, 0x00, 0x00};
      unsigned char bytestring_swap_short[] = {0x33, 0x41, 0x80, 0x54, 0x99, 0xFF, 0x78, 0x01, 0x20, 0x55, 0xFE, 0xEE, 0x00, 0x00, 0x00, 0x00};
         unsigned char bytestring_swap_long[] = {0x78, 0x01, 0x99, 0xFF, 0x80, 0x54, 0x33, 0x41, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xFE, 0x20, 0x55};


Part 1: Data Types and their Sizes
========================
Byte Size: 8 bits
Short Int Size: 16 bits
Integer Size: 32 bits
Long Integer Size: 64 bits
========================
Part 2: Byte Ordering
========================
Byte Values of entire array (show as hexadecimal values, e.g., C7):
** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **
Short Int versions of the first four values of an array in hexadecimal:
3341 8054 99ff 7801 
Int versions of the first two values of an array in hexadecimal:
80543341 780199ff 
Long Int version of the first value of an array in hex:
780199ff80543341 
2e: ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **
2f: **** **** **** ****
2g: ******** ********
2h: ****************
========================
Part 3: Unsigned Addition of Small Fields ========================
0x20 + 0x35 = 0x**
0x80 + 0x7F = 0x**
0x80 + 0xFF = 0x**
0xFF + 0x01 = 0x**
========================
Part 4: Detecting a Carry condition
========================
0x20 + 0x35 Carry: *  (0 or 1)
0x80 + 0x7F Carry: *
0x80 + 0xFF Carry: *
0xFF + 0x01 Carry: *
========================
Part 5: Signed Addition and Overflow
========================
0x20 + 0x35 Overflow: *
0x80 + 0x7F Overflow: *
0x80 + 0xFF Overflow: *
0xFF + 0x01 Overflow: *
========================
Part 6: Performing Extended Field Arithmetic
========================
6a)
   0x44  0x00  0x00  0x00  0x01
+  0x30  0xFF  0xFF  0x00  0x00
=  0x**  0x**  0x**  0x**  0x**
Carry Out = *
6b)
  0xFF  0xFF  0xFF  0xFF  0xFF
+ 0x00  0x00  0x00  0x00  0x01
= 0x**  0x**  0x**  0x**  0x**
Carry Out = *
========================
